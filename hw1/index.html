<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Author: Yuan Xu, SID: 3039823660, Collaborators: None</h2>
<a href="https://cal-cs184-student.github.io/hw-webpages-sp24-moonight3547/hw1/index.html">Visit My Website!</a>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<h3>Implementation Overview</h3>
<p>
In this assignment, we first learned how to rasterize a single-color triangle without oversampling. Then, we learned the oversampled triangle rasterization and implementation of translate/scale/rotate transform. After that, we rasterize multi-color triangles with barycentric interpolation, and rasterize textured triangles with texture filtering and level sampling. Two basic methods are linear interpolation and nearest method.
We also implement the extra credit for Task 1, optimizing the efficiency to rasterize a triangle using segment intersections instead of point-in-triangle tests. 
</p>
<h3>Framework Overview</h3>
<p>
As a whole, we've built the rasterization part in this assignment. 
In the framework, the DrawRend renderer will redraw the GUI window at a frequency or after some key input. 
When redrawing, the renderer will invoke the methods we implemented to rasterize all the points, lines, and triangles (triangulation is given in the framework). 
</p>
<h3>My Thoughts</h3>
<p>
I learned many interesting things when completing the assignment. I learned a framework to transform SVG objects into NDC and NDC into screen-space. In the framework, I implemented the details of rasterization using oversampling for antialiasing, bilinear interpolation and nearest method for texture sampling, mipmaping for level sampling. 
The assignment not only help me review these concepts but also give me an opportunity to understand how they work actually. Besides, I also gain experience in solving detailed problems like how to deal with the boundary of triangles and data out of range. Extra credits are greatly designed but I only solve that of Task 1 due to the time issue. 
But the efficiency improvement in triangle rasterization also help me practice a lot in algorithm designs and programming. 
</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>
<h4 align="middle">Algorithm Description</h4> 
<p>First, we can find out the bounding box of the triangle by find the minimum/maximum x,y values of the three given points of the triangle. 
Then, check each pixel $(x,y)$ in the bounding box whether the sample point $(x+0.5,y+0.5)$ is inside the triangle. If the sample point is inside the triangle, we fill the pixel with the given color of the triangle. 
</p>
<h4 align="middle">Algorithm Effciency</h4>
<p> Since we first find out the bounding box inside the viewplot. We only check those pixels in the bounding box whether the sample point of the pixel is inside the triangle in $O(1)$ time (constant time). Notice that the constant runtime of point-in-triangle test is large since it takes three line test and each includes a lot of calculation. 
</p>
<h4 align="middle">Screenshot</h4>
<img src="hw1-task1test4.png" width="400" height="400" />
<h4 align="middle">Extra Credit</h4>
We can use chrono::high_resolution_clock::now() to record the start time and end time of the redraw() function of DrawRend class. The optimization is much more obvious for 

<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>

<h3 align="middle">Part 2: Antialiasing triangles</h3>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
	<img src="hw1-task2test4sr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task2test4sr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 1</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
	<img src="hw1-task2test4sr4.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 4</figcaption>
      </td>
      <td>
	<img src="hw1-task2test4sr16.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 16</figcaption>
      </td>
    </tr>
  </table>
</div>




<h3 align="middle">Part 3: Transforms</h3>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>
None. 
</body>
</html>
