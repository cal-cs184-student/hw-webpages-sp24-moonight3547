<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Author: Yuan Xu, SID: 3039823660, Collaborators: None</h2>
<div align="middle">
<p>Link to write-up website: <a href="https://cal-cs184-student.github.io/hw-webpages-sp24-moonight3547/hw1/index.html">Visit My Website!</a>
 </p>
</div>
<br><br>

<div>

<h2 align="middle">Overview</h2>
<h3>Implementation Overview</h3>
<p>
In this assignment, we first learned how to rasterize a single-color triangle without oversampling. Then, we learned the oversampled triangle rasterization and implementation of translate/scale/rotate transform. After that, we rasterize multi-color triangles with barycentric interpolation, and rasterize textured triangles with texture filtering and level sampling. Two basic methods are linear interpolation and nearest method.
We also implement the extra credit for Task 1, optimizing the efficiency to rasterize a triangle using segment intersections instead of point-in-triangle tests. 
</p>
<h3>Framework Overview</h3>
<p>
As a whole, we've built the rasterization part in this assignment. 
In the framework, the DrawRend renderer will redraw the GUI window at a frequency or after some key input. 
When redrawing, the renderer will invoke the methods we implemented to rasterize all the points, lines, and triangles (triangulation is given in the framework). 
</p>
<h3>My Thoughts</h3>
<p>
I learned many interesting things when completing the assignment. I learned a framework to transform SVG objects into NDC and NDC into screen-space. In the framework, I implemented the details of rasterization using oversampling for antialiasing, bilinear interpolation and nearest method for texture sampling, mipmaping for level sampling. 
The assignment not only help me review these concepts but also give me an opportunity to understand how they work actually. Besides, I also gain experience in solving detailed problems like how to deal with the boundary of triangles and data out of range. Extra credits are greatly designed but I only solve that of Task 1 due to the time issue. 
But the efficiency improvement in triangle rasterization also help me practice a lot in algorithm designs and programming. 
</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>
<h4 align="middle">Algorithm Description</h4> 
<p>First, we can find out the bounding box of the triangle by find the minimum/maximum x,y values of the three given points of the triangle. 
Then, check each pixel (x,y) in the bounding box whether the sample point (x+0.5,y+0.5) is inside the triangle. If the sample point is inside the triangle, we fill the pixel with the given color of the triangle. 
</p>
<h4 align="middle">Algorithm Effciency</h4>
<p> Since we first find out the bounding box inside the viewplot. We only check those pixels in the bounding box whether the sample point of the pixel is inside the triangle in O(1) time (constant time). Notice that the constant runtime of point-in-triangle test is large since it takes three line test and each includes a lot of calculation. Although this method takes a lot of time when the number of triangles is very large (e.g. svg/basic/test3.svg), the algorithm is no worse than one that checks each sample within the bounding box of the triangle since we ignore the part of triangle that outside the frame. 
</p>
<h4 align="middle">Screenshot</h4>
<p>We can find the screenshot of drawing svg/basic/test4.svg without oversampling below. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
	<img src="hw1-task1test3.png" align="middle" width="400" />
	<figcaption align="middle">basic/test3.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task1test4.png" align="middle" width="400" />
	<figcaption align="middle">basic/test4.svg without oversampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
	<img src="hw1-task1test5.png" align="middle" width="400" />
	<figcaption align="middle">basic/test5.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task1test6.png" align="middle" width="400" />
	<figcaption align="middle">basic/test6.svg without oversampling</figcaption>
      </td>
    </tr>
  </table>
</div>
<h4 align="middle">Extra Credit</h4>
<p>The optimized algorithm is to calculate the intersection of the three edges of a triangle with the axis y equal to each possible value. All the pixels on the axis with x-value between the minimum x-value of intersection and the maximum x-value of intersection must be also inside the triangle since triangles are convex hulls. In this way, we don't need to calculate that much for point-in-triangle test and need to only fill the pixels in the triangle (about half the bounding box). 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
				<img src="hw1-task1origtime.jpg" align="middle" width="400" />
        <figcaption align="middle">original runtime to draw the svg files for one time</figcaption>
      </td>
      <td>
				<img src="hw1-task1extratime.jpg" align="middle" width="400" />
        <figcaption align="middle">optimized runtime to draw the svg files for one time</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>We can use chrono::high_resolution_clock::now() to record the start time and end time of svg.draw() inside the redraw() function of DrawRend class. Then we output the time cost each time we redraw the viewer. The optimization is much more obvious for svg files with more triangles to rasterize. For example, the SVG file svg/basic/test3.svg has many triangles to rasterize and the original algorithm takes about 11 times more runtime than the optimized algorithm to redraw the viewer. The optimization has about 1000% improvement in execution time performance. 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>SVG Files:</td>
      <td>svg/basic/test3.svg</td>
      <td>svg/basic/test4.svg</td>
      <td>svg/basic/test5.svg</td>
      <td>svg/basic/test6.svg</td>
    </tr>
    <br>
    <tr>
      <td>Original time:</td>
      <td>46 ms</td>
      <td>3 ms</td>
      <td>11 ms</td>
      <td>9 ms</td>
    </tr>
    <tr>
      <td>Optimized time:</td>
      <td>4 ms</td>
      <td>0 ms</td>
      <td>1 ms</td>
      <td>1 ms</td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>
<h4 align="middle">Algorithm Description</h4>

<h4 align="middle">Implementation Explanation</h4>
<h4 align="middle">Screenshot</h4>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
				<img src="hw1-task2test4osr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg without oversampling</figcaption>
      </td>
      <td>
				<img src="hw1-task2test4osr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 1</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
				<img src="hw1-task2test4osr4.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 4</figcaption>
      </td>
      <td>
				<img src="hw1-task2test4osr16.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 16</figcaption>
      </td>
    </tr>
  </table>
</div>




<h3 align="middle">Part 3: Transforms</h3>
<h4 align="middle">Algorithm Description</h4>
We fill the translate,scale,rotate functions in transform.cpp with the 3x3 matrices provided in the lecture. 
<div align="middle">
	<img src="hw1-task3matrices.png" align="middle" width="400" />
	<figcaption align="middle">The matrices for 2D translate, scale, rotate operation</figcaption>
</div>
<h4 align="middle">SVG File Description</h4>
<p>The SVG file is stored under docs/ directory. It is a modified version of svg/transform/robot.svg with some translate, scale, rotate operations to each components of the cubeman. 
</p>
<h4 align="middle">Screenshot</h4>
The cubeman is now running towards right and waving his two hands to keep balance. 
<div align="middle">
	<img src="hw1-task3myrobotrun.png" align="middle" width="400" />
	<figcaption align="middle">docs/my_robot.svg a running run waving his hands</figcaption>
</div>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
<h4 align="middle">Barycentric Coordinates Explanation</h4>
<p>Barycentric coordinates is a system of coordinates to linearly interpolate some value at any points inside a given triangle with given values at the three vertices. The value at each point is a linear combination of the values at the three vertices with the distance from the three edges as the coefficients. Barycentric coordinates help us to construct a smooth function of values inside the triangle area which can help us fill the the area with smooth colors or textures. 
</p>
<h4 align="middle">Triangle Example</h4>
<p>In the right example, we have a smoothly blended color regular triangle with three vertices of red, green, and blue. The color of the intermediate pixels inside the regular triangle are interpolated from these three vertices as a combination with different coefficients of these three colors. The coefficients depends on the distance away from each vertex. The farther the pixel is away from the red vertex, the less the color is red. The center of the regular triangle blends all the three colors. Red and green are blended into yellow, while red and blue are blended into purple. 
</p>
<h4 align="middle">Screenshot</h4>
<p>On the left below, we have a png screenshot of svg/basic/test7.svg with color gradients with default viewing parameters and sample rate 1. 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
				<img src="hw1-task4colorgrad.png" align="middle" width="400" />
        <figcaption align="middle">basic/test7.svg a disk of color gradient</figcaption>
      </td>
      <td>
				<img src="hw1-task4mycolorgrad.png" align="middle" width="400" />
        <figcaption align="middle">a regular triangle of color gradient</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>
On the right-hand side, we give another example of color gradients in regular triangle shape. 
</p>

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<h4 align="middle">Pixel Sampling Explanation & Implementation</h4>
<p>Pixel sampling is the process of getting the color of a pixel in screen-space from an estimated position in the given texture image. First, we have an ideal corresponding position in the texture space for a pixel in screen-space estimated by barycentric coordinates system we discussed above. Then, we can implement pixel sampling by nearest sampling method or bilinear sampling method. These two pixel sampling methods help us get the color of a screen-space pixel from a corresponding point in the texture image. 
</p>
<p>The ideal point is estimated (interpolated) by barycentric coordinates. For nearest sampling, we select the color of the pixel in the texture image which is the nearest from the ideal point. For bilinear sampling method, we find the nearest four sampling point (u,v), (u,v+1), (u+1,v), (u+1,v+1) and use their color value to linearly interpolate the color value of the ideal point. The linear interpolation in bilinear sampling uses the lerp() function to find the interpolated value as a linear combination of the values of two closest integer points. 
</p>
<h4 align="middle">Two Methods Discussion</h4>
From the screenshots below, we can find that bilinear pixel sampling gives us more smoothly textured images. The image of nearest pixel sampling with sample rate 1 is pixelated and not smooth with many jaggies. The image of bilinear pixel sampling with sample rate 1 is much more smooth than the image of nearest pixel sampling with sample rate 1. Nearest pixel sampling with oversampling of sample rate 16 can also help make the image more smooth and reduce the jaggies and aliasing. Bilinear sampling with sample rate 16 is also smooth but a little blurred. Difference between the two pixel sampling methods: nearest pixel sampling can provides a clear but jaggy result since it only select the nearest pixel, while bilinear pixel sampling provides a smooth but a little blurred since it combines multiple surrounding pixels. 
<h4 align="middle">Screenshot</h4>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
				<img src="hw1-task5nearestsr1.png" align="middle" width="400" />
        <figcaption align="middle">svg/texmap/test5.svg with <br>nearest pixel sampling and sample rate 1</figcaption>
      </td>
      <td>
				<img src="hw1-task5nearestsr16.png" align="middle" width="400" />
        <figcaption align="middle">svg/texmap/test5.svg with <br>nearest pixel sampling and sample rate 16</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
				<img src="hw1-task5bilinearsr1.png" align="middle" width="400" />
        <figcaption align="middle">svg/texmap/test5.svg with <br>bilinear pixel sampling and sample rate 1</figcaption>
      </td>
      <td>
				<img src="hw1-task5bilinearsr16.png" align="middle" width="400" />
        <figcaption align="middle">svg/texmap/test5.svg with <br>bilinear pixel sampling and sample rate 16</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<h4 align="middle">Level Sampling Explanation & Implementation</h4>
Level sampling is the process to find the appropriate mipmap level to use in texture sampling. We have three methods to select the level for sampling: level zero, nearest sampling, linear sampling. Level zero sampling is the easiest. We implement this 
	Level Sampling is the process of finding the right mipmap level to use for the corresponding image. We do this by taking the derivative of 1 pixel with respect to dx and dy, then using Barycentric coordinates to convert it into the uv space. This allows us to see how stretched out or compressed our image is and will allow us to determine which mipmap level the image should be at. We implemented mipmap level zero, nearest level sampling, and bilinear level. The mipmap level zeros uses only the level zero mipmap with the highest resolution. The nearest level sampling will calculate the max derivative and take the log base 2 then round to the nearest mipmap level. The bilinear level will interpolate between the two closes mipmap levels, taking the floor and ceiling of the level value, finding the texture color for both levels, then linearly interpolating between the two colors.
Pixel sampling is able to run relatively quickly to the original algorithm since it will just be finding the point directly from the texture map, however bilinear pixel sampling may take up more time since we will need to do 3 lerp functions, pixel sampling will be the worst at antialiasing power because it applies the pixel sampling over the entire image and can make the entire image crisp or blurry. Level sampling employs the use of mipmaps which are images but at multiple resolutions and uses the image to figure out the best mipmap level to use that will create the clearest image. This takes up more memory usage because we need to store the additional mipmaps however it performs well at antialiasing because it can change blurriness or reduce high frequencies at different areas. The runtime also takes a bit longer since we need to compute barycentric coordinates for different mipmap levels, however performs well at creating an image that is antialised. Changing the number of pixels allows us to create more subsamples per pixel and sample the image more. This works well at reducing high frequncy changes int eh image and thus works well for antialiasing, however it had a large impace on runtime in that each subsample must be sampled. The memory impact will depend on the number of subsamples since the memory storage for pixel colors will be multiplied by the number of subsamples.

<h4 align="middle">Tradeoff</h4>
<p>Consider the tradeoffs between pixel sampling, level sampling, and the number of samples per pixel in terms of speed, memory usage, and anti-aliasing power. 
</p>
<p>Speed: Nearest pixel sampling can be relatively faster compared to bilinear sampling and other techniques since it samples each pixel individually without considering neighboring pixels. But bilinear sampling may take more time compared to linear level sampling since bilinear sampling use four sample points while linear level sampling only use two. Involving sampling pixels at different levels, level sampling generally takes more time compared with pixel sampling. Oversampling with multiple samples per pixel must be slowest since it requires at least $4$ sample points and sometimes needs about $16$ sample points to have good performance. 
</p>
<p>Memory usage: Pixel sampling use the the least memory since it only needs to store information about each pixel being sampled. Level sampling use more memory space since it need to store information at multiple levels of mipmapping. Oversampling at high sample counts takes the largest memory space since it need to store all the sample results for each pixel. The memory usage is linearly increasing with the number of samples per pixel. 
</p>
<p>Anti-aliasing Power: Pixel sampling may not provide strong anti-aliasing effect, especially nearest pixel sampling. Nearest pixel sampling gives pixelated and jaggy results and has no anti-aliasing power. Bilinear pixel sampling provides a more smooth result and help anti-aliasing. Considering neighbor pixels at different levels, level sampling can provide better anti-aliasing effects compared with pixel sampling. Oversampling with multiple samples per pixel can greatly improves anti-aliasing by reducing noise and aliasing artifacts. 
</p>
<p>In summary, the choice of sampling technique depends on the specific requirements of the rendering/rasterization/texturing task, including factors like speed, memory usage and anti-aliasing power. Pixel sampling has fast speed and small memory usage but is not that good at anti-aliasing. Level sampling provides a moderate choice between the balance of speed, memory and anti-aliasing power. Oversampling with multiple samples per pixel can greatly improve anti-aliasing power but takes much more time and memory. 
</p>

<h4 align="middle">Screenshot</h4>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
				<img src="hw1-task6lvl0nearestsr1.png" align="middle" width="400" />
        <figcaption align="middle">docs/my_texture.svg with level zero <br>sampling and nearest pixel sampling</figcaption>
      </td>
      <td>
				<img src="hw1-task6lvl0bilinearsr1.png" align="middle" width="400" />
        <figcaption align="middle">docs/my_texture.svg with level zero <br>sampling and bilinear pixel sampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
				<img src="hw1-task6nearestnearestsr1.png" align="middle" width="400" />
        <figcaption align="middle">docs/my_texture.svg with nearest <br>level sampling and nearest pixel sampling</figcaption>
      </td>
      <td>
				<img src="hw1-task6nearestbilinearsr1.png" align="middle" width="400" />
        <figcaption align="middle">docs/my_texture.svg with nearest <br>level sampling and bilinear pixel sampling</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>
None. 
</body>
</html>
