<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Author: Yuan Xu, SID: 3039823660, Collaborators: None</h2>
<a href="https://cal-cs184-student.github.io/hw-webpages-sp24-moonight3547/hw1/index.html">Visit My Website!</a>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<h3>Implementation Overview</h3>
<p>
In this assignment, we first learned how to rasterize a single-color triangle without oversampling. Then, we learned the oversampled triangle rasterization and implementation of translate/scale/rotate transform. After that, we rasterize multi-color triangles with barycentric interpolation, and rasterize textured triangles with texture filtering and level sampling. Two basic methods are linear interpolation and nearest method.
We also implement the extra credit for Task 1, optimizing the efficiency to rasterize a triangle using segment intersections instead of point-in-triangle tests. 
</p>
<h3>Framework Overview</h3>
<p>
As a whole, we've built the rasterization part in this assignment. 
In the framework, the DrawRend renderer will redraw the GUI window at a frequency or after some key input. 
When redrawing, the renderer will invoke the methods we implemented to rasterize all the points, lines, and triangles (triangulation is given in the framework). 
</p>
<h3>My Thoughts</h3>
<p>
I learned many interesting things when completing the assignment. I learned a framework to transform SVG objects into NDC and NDC into screen-space. In the framework, I implemented the details of rasterization using oversampling for antialiasing, bilinear interpolation and nearest method for texture sampling, mipmaping for level sampling. 
The assignment not only help me review these concepts but also give me an opportunity to understand how they work actually. Besides, I also gain experience in solving detailed problems like how to deal with the boundary of triangles and data out of range. Extra credits are greatly designed but I only solve that of Task 1 due to the time issue. 
But the efficiency improvement in triangle rasterization also help me practice a lot in algorithm designs and programming. 
</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>
<h4 align="middle">Algorithm Description</h4> 
<p>First, we can find out the bounding box of the triangle by find the minimum/maximum x,y values of the three given points of the triangle. 
Then, check each pixel $(x,y)$ in the bounding box whether the sample point $(x+0.5,y+0.5)$ is inside the triangle. If the sample point is inside the triangle, we fill the pixel with the given color of the triangle. 
</p>
<h4 align="middle">Algorithm Effciency</h4>
<p> Since we first find out the bounding box inside the viewplot. We only check those pixels in the bounding box whether the sample point of the pixel is inside the triangle in $O(1)$ time (constant time). Notice that the constant runtime of point-in-triangle test is large since it takes three line test and each includes a lot of calculation. Although this method takes a lot of time when the number of triangles is very large (e.g. svg/basic/test3.svg), the algorithm is no worse than one that checks each sample within the bounding box of the triangle since we ignore the part of triangle that outside the frame. 
</p>
<h4 align="middle">Screenshot</h4>
<p>Below is the screenshot of drawing svg/basic/test4.svg without oversampling. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
	<img src="hw1-task1test3.png" align="middle" width="400" />
	<figcaption align="middle">basic/test3.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task1test4.png" align="middle" width="400" />
	<figcaption align="middle">basic/test4.svg without oversampling</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
	<img src="hw1-task1test5.png" align="middle" width="400" />
	<figcaption align="middle">basic/test5.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task1test6.png" align="middle" width="400" />
	<figcaption align="middle">basic/test6.svg without oversampling</figcaption>
      </td>
    </tr>
  </table>
</div>
<h4 align="middle">Extra Credit</h4>
<p>The optimized algorithm is to calculate the intersection of the three edges of a triangle with the axis $y$ equal to each possible value. All the pixels on the axis with x-value between the minimum x-value of intersection and the maximum x-value of intersection must be also inside the triangle since triangles are convex hulls. In this way, we don't need to calculate that much for point-in-triangle test and need to only fill the pixels in the triangle (about half the bounding box). 
</p>
<p>We can use chrono::high_resolution_clock::now() to record the start time and end time of the redraw() function of DrawRend class. Then we output the time cost each time we redraw the viewer. The optimization is much more obvious for svg files with more triangles to rasterize. For example, the SVG file svg/basic/test3.svg has many triangles to rasterize and the original algorithm takes about $100$ times more runtime than the optimized algorithm to redraw the viewer. 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
	<img src="hw1-task1time.jpg" align="middle" width="400" />
        <figcaption align="middle">original runtime to draw the svg files for one time</figcaption>
      </td>
      <td>
	<img src="hw1-task1extra.jpg" align="middle" width="400" />
        <figcaption align="middle">optimized runtime to draw the svg files for one time</figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>SVG Files:</td>
      <td>svg/basic/test3.svg</td>
      <td>svg/basic/test4.svg</td>
      <td>svg/basic/test5.svg</td>
      <td>svg/basic/test6.svg</td>
    </tr>
    <br>
    <tr>
      <td>Original time:</td>
      <td>6484 ms</td>
      <td>73 ms</td>
      <td>104 ms</td>
      <td>617 ms</td>
    </tr>
    <tr>
      <td>Optimized time:</td>
      <td>59 ms</td>
      <td>55 ms</td>
      <td>53 ms</td>
      <td>54 ms</td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
	<img src="hw1-task2test4sr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg without oversampling</figcaption>
      </td>
      <td>
	<img src="hw1-task2test4sr1.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 1</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
	<img src="hw1-task2test4sr4.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 4</figcaption>
      </td>
      <td>
	<img src="hw1-task2test4sr16.png" align="middle" width="400" />
        <figcaption align="middle">basic/test4.svg with sample rate 16</figcaption>
      </td>
    </tr>
  </table>
</div>




<h3 align="middle">Part 3: Transforms</h3>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>
None. 
</body>
</html>
